CALL apoc.load.xml($xml_url) YIELD value as root

UNWIND [v in root._children WHERE v._type = 'group'] as value
// Groups can be comma-separated; splits them and creates one Group node per name (MERGE ensures no duplicates)
UNWIND apoc.text.split(value.name, ",") AS groupName
MERGE (g:Group {name: groupName}) //create group
//Extract rules inside the group
WITH value, g
UNWIND [c IN value._children WHERE c IS NOT NULL AND c._type = "rule"] AS parsed_rule
// Extract parent id (if_sid or if_matched_sid value)
WITH parsed_rule, g,
         [elem IN parsed_rule._children WHERE elem._type IN ["if_sid", "if_matched_sid"]] AS elems
WITH parsed_rule, g,
        CASE WHEN size(elems) > 0 THEN apoc.text.split(elems[0]._text, ",")[0] ELSE NULL END AS parent_id

MERGE (rule_node:Rule {id: parsed_rule.id, source_file: $xml_url}) //create rule node
SET rule_node.parent = parent_id  // save parent ID as a property
MERGE (rule_node)-[:BELONGS]->(g) // assign rule node to group

// add the inline rule properties like frequency
WITH parsed_rule,  rule_node
CALL (parsed_rule,  rule_node) {
        //Filter rule properties to ignore internal ones (those starting with _)
        WITH [prop_name IN keys(parsed_rule) WHERE NOT prop_name STARTS WITH "_"] AS prop_names, parsed_rule,  rule_node
        //Set remaining properties (like frequency, level, etc.) on the rule node
        CALL apoc.create.setProperties(rule_node, prop_names, [prop_name IN prop_names | parsed_rule[prop_name]]) YIELD node
        RETURN node
}

// add group relation (add additional groups listed within a rule - a rule may refer to additional groups)
WITH parsed_rule,  rule_node
CALL (parsed_rule,  rule_node) {
        WITH [gr IN parsed_rule._children WHERE gr._type='group'] AS groupElems, parsed_rule,  rule_node
        UNWIND groupElems AS groupElem
        UNWIND apoc.text.split(groupElem._text, ",") AS groupName
        MERGE (gg:Group {name: groupName})
        MERGE (rule_node)-[:BELONGS]->(gg)
}

// add the attributes dynamically
CALL (parsed_rule, rule_node) {
  UNWIND parsed_rule._children AS child
  WITH child, rule_node
  WHERE child._type IS NOT NULL AND NOT child._type IN ['group', 'if_matched_sid', 'field', 'if_sid']

  WITH rule_node, child._type AS key, 
       CASE 
         WHEN child._text IS NOT NULL THEN child._text 
         ELSE true 
       END AS value

  CALL apoc.create.setProperty(rule_node, key, value) YIELD node
  return node
}


// add named fields
CALL (parsed_rule, rule_node) {
	  // for each field, create a property on the rule like '"Field: myFieldName = "value"'
	  UNWIND [field IN parsed_rule._children WHERE field._type = "field"] AS field

	  // Set main field content
	  WITH rule_node, field,
		   "Field:" + field.name AS main_key,
		   field._text AS main_value,
		   apoc.map.removeKey(field, "_type") AS attrs  // get all field attributes

	  CALL apoc.create.setProperty(rule_node, main_key, main_value) YIELD node AS updated1

	  // Now process all other attributes except `name`
	  WITH updated1, field.name AS field_name, attrs
	  UNWIND [k IN keys(attrs) WHERE k <> "name"] AS attr_key
	  WITH updated1, "Field." + field_name + "." + attr_key AS attr_prop, attrs[attr_key] AS attr_val

	  CALL apoc.create.setProperty(updated1, attr_prop, attr_val) YIELD node AS updated2
	  RETURN updated2

}

RETURN rule_node, parsed_rule



